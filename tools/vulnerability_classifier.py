"""
Automated Vulnerability Classification and Prioritization System
Intelligent analysis and scoring of casino vulnerabilities for optimal targeting
"""

import json
import logging
import re
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
import math

logger = logging.getLogger(__name__)


class VulnerabilitySeverity(Enum):
    """Standardized vulnerability severity levels"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


class VulnerabilityType(Enum):
    """Comprehensive vulnerability type classification"""
    CAPTCHA_BYPASS = "captcha_bypass"
    BULK_CREATION = "bulk_creation"
    WEAK_VALIDATION = "weak_validation"
    MISSING_VERIFICATION = "missing_verification"
    API_EXPOSURE = "api_exposure"
    WEAK_PASSWORD_POLICY = "weak_password_policy"
    RATE_LIMITING_BYPASS = "rate_limiting_bypass"
    SESSION_MANAGEMENT = "session_management"
    INSECURE_COMMUNICATION = "insecure_communication"
    INFORMATION_DISCLOSURE = "information_disclosure"
    CROSS_SITE_SCRIPTING = "cross_site_scripting"
    SQL_INJECTION = "sql_injection"
    REMOTE_CODE_EXECUTION = "remote_code_execution"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    DENIAL_OF_SERVICE = "denial_of_service"
    BUSINESS_LOGIC_FLaw = "business_logic_flaw"


@dataclass
class VulnerabilityScore:
    """Comprehensive vulnerability scoring"""
    overall_score: float = 0.0  # 0.0 to 10.0
    severity_score: float = 0.0  # Based on severity level
    exploitability_score: float = 0.0  # How easy to exploit
    impact_score: float = 0.0  # Potential impact
    detection_confidence: float = 0.0  # How confident we are in the finding
    priority_rank: int = 0  # 1-100, higher = more important
    recommended_action: str = ""
    time_to_exploit: str = ""  # estimated time to develop exploit
    profit_potential_score: float = 0.0  # 0.0 to 10.0
    risk_assessment: str = ""
    mitigation_complexity: str = ""  # easy, medium, hard, very_hard


@dataclass
class ClassifiedVulnerability:
    """Fully classified vulnerability with comprehensive analysis"""
    original_vulnerability: Dict[str, Any]
    classification: VulnerabilityScore
    enhanced_metadata: Dict[str, Any] = field(default_factory=dict)
    similar_vulnerabilities: List[Dict] = field(default_factory=list)
    exploitation_vectors: List[str] = field(default_factory=list)
    affected_systems: List[str] = field(default_factory=list)
    compliance_violations: List[str] = field(default_factory=list)
    business_impact: Dict[str, Any] = field(default_factory=dict)
    classification_timestamp: str = ""

    def __post_init__(self):
        if not self.classification_timestamp:
            self.classification_timestamp = datetime.now().isoformat()


class VulnerabilityClassifier:
    """
    Advanced vulnerability classification system using machine learning principles
    and expert knowledge to prioritize casino vulnerabilities for maximum impact.
    """

    def __init__(self):
        # Severity scoring weights
        self.severity_weights = {
            VulnerabilitySeverity.CRITICAL: 10.0,
            VulnerabilitySeverity.HIGH: 7.5,
            VulnerabilitySeverity.MEDIUM: 5.0,
            VulnerabilitySeverity.LOW: 2.5,
            VulnerabilitySeverity.INFO: 1.0
        }

        # Exploitability scoring (how easy to exploit)
        self.exploitability_factors = {
            'easy': 9.0,
            'medium': 6.0,
            'hard': 3.0,
            'theoretical': 1.0
        }

        # Vulnerability type specific scoring
        self.vulnerability_type_weights = {
            VulnerabilityType.CAPTCHA_BYPASS: {'severity': 1.5, 'exploitability': 1.3, 'profit': 2.0},
            VulnerabilityType.BULK_CREATION: {'severity': 1.4, 'exploitability': 1.4, 'profit': 1.8},
            VulnerabilityType.WEAK_VALIDATION: {'severity': 1.2, 'exploitability': 1.3, 'profit': 1.5},
            VulnerabilityType.MISSING_VERIFICATION: {'severity': 1.3, 'exploitability': 1.2, 'profit': 1.6},
            VulnerabilityType.API_EXPOSURE: {'severity': 1.6, 'exploitability': 1.1, 'profit': 1.4},
            VulnerabilityType.WEAK_PASSWORD_POLICY: {'severity': 1.1, 'exploitability': 1.4, 'profit': 1.3},
            VulnerabilityType.RATE_LIMITING_BYPASS: {'severity': 1.3, 'exploitability': 1.5, 'profit': 1.7},
            VulnerabilityType.SESSION_MANAGEMENT: {'severity': 1.8, 'exploitability': 1.2, 'profit': 1.5},
            VulnerabilityType.INSECURE_COMMUNICATION: {'severity': 1.7, 'exploitability': 1.1, 'profit': 1.2},
            VulnerabilityType.INFORMATION_DISCLOSURE: {'severity': 1.4, 'exploitability': 1.0, 'profit': 1.1},
            VulnerabilityType.CROSS_SITE_SCRIPTING: {'severity': 1.6, 'exploitability': 1.3, 'profit': 1.4},
            VulnerabilityType.SQL_INJECTION: {'severity': 2.0, 'exploitability': 1.4, 'profit': 1.8},
            VulnerabilityType.REMOTE_CODE_EXECUTION: {'severity': 2.5, 'exploitability': 1.6, 'profit': 2.5},
            VulnerabilityType.PRIVILEGE_ESCALATION: {'severity': 2.2, 'exploitability': 1.5, 'profit': 2.0},
            VulnerabilityType.DENIAL_OF_SERVICE: {'severity': 1.8, 'exploitability': 1.3, 'profit': 1.2},
            VulnerabilityType.BUSINESS_LOGIC_Flaw: {'severity': 1.9, 'exploitability': 1.4, 'profit': 2.2}
        }

        # Casino-specific impact multipliers
        self.casino_impact_multipliers = {
            'account_creation': 2.0,  # Critical for casino abuse
            'bonus_system': 1.8,      # High profit potential
            'payment_processing': 1.9, # Financial impact
            'user_data': 1.6,         # Privacy concerns
            'game_logic': 2.2,        # Fairness and trust
            'licensing': 1.7,         # Regulatory compliance
            'infrastructure': 1.5     # Operational impact
        }

        # Initialize pattern matching for vulnerability types
        self.vulnerability_patterns = self._initialize_patterns()

    def _initialize_patterns(self) -> Dict[str, List[str]]:
        """Initialize regex patterns for vulnerability type detection"""
        return {
            'captcha_bypass': [
                r'no.*captcha', r'captcha.*bypass', r'missing.*captcha',
                r'captcha.*not.*present', r'bypass.*captcha'
            ],
            'bulk_creation': [
                r'bulk.*creation', r'multiple.*account', r'mass.*registration',
                r'account.*creation.*possible', r'unlimited.*account'
            ],
            'weak_validation': [
                r'weak.*validation', r'no.*pattern', r'missing.*validation',
                r'optional.*email', r'validation.*bypass'
            ],
            'missing_verification': [
                r'no.*verification', r'missing.*phone', r'no.*email.*verification',
                r'phone.*not.*required', r'verification.*bypass'
            ],
            'api_exposure': [
                r'api.*endpoint', r'exposed.*api', r'api.*vulnerable',
                r'endpoint.*discovery', r'api.*access'
            ],
            'weak_password': [
                r'weak.*password', r'password.*policy', r'password.*requirements',
                r'no.*password.*complexity', r'password.*validation'
            ],
            'rate_limiting': [
                r'rate.*limit', r'no.*rate.*limit', r'bypass.*rate.*limit',
                r'rate.*limiting.*bypass', r'unlimited.*attempt'
            ],
            'session_management': [
                r'session.*management', r'session.*fixation', r'cookie.*vulnerable',
                r'session.*hijacking', r'insecure.*session'
            ],
            'insecure_communication': [
                r'http.*only', r'no.*https', r'insecure.*connection',
                r'plaintext.*communication', r'unencrypted.*data'
            ],
            'information_disclosure': [
                r'information.*disclosure', r'debug.*information', r'exposed.*data',
                r'sensitive.*data.*leak', r'version.*disclosure'
            ]
        }

    def classify_vulnerabilities(self, vulnerabilities: List[Dict]) -> List[ClassifiedVulnerability]:
        """
        Classify and score a list of vulnerabilities

        Args:
            vulnerabilities: List of vulnerability dictionaries

        Returns:
            List of classified vulnerabilities with enhanced scoring
        """
        classified = []

        for vuln in vulnerabilities:
            try:
                classified_vuln = self.classify_single_vulnerability(vuln)
                classified.append(classified_vuln)
            except Exception as e:
                logger.warning(f"Failed to classify vulnerability: {e}")
                # Add with default classification
                classified_vuln = ClassifiedVulnerability(
                    original_vulnerability=vuln,
                    classification=VulnerabilityScore()
                )
                classified.append(classified_vuln)

        # Sort by priority rank (highest first)
        classified.sort(key=lambda x: x.classification.priority_rank, reverse=True)

        return classified

    def classify_single_vulnerability(self, vulnerability: Dict) -> ClassifiedVulnerability:
        """
        Classify a single vulnerability with comprehensive analysis

        Args:
            vulnerability: Vulnerability dictionary

        Returns:
            ClassifiedVulnerability with full analysis
        """
        # Extract basic information
        title = vulnerability.get('title', '')
        description = vulnerability.get('description', '')
        severity_str = vulnerability.get('severity', 'medium')
        vuln_type_str = vulnerability.get('vulnerability_type', 'unknown')
        exploitability = vulnerability.get('exploitability', 'medium')
        profit_potential = vulnerability.get('profit_potential', 'medium')

        # Convert to enums
        severity = self._parse_severity(severity_str)
        vuln_type = self._classify_vulnerability_type(title, description, vuln_type_str)

        # Calculate comprehensive score
        score = self._calculate_vulnerability_score(
            severity, vuln_type, exploitability, profit_potential,
            title, description, vulnerability
        )

        # Enhance with additional metadata
        enhanced_metadata = self._generate_enhanced_metadata(vulnerability, score)

        # Find similar vulnerabilities (simplified)
        similar_vulns = self._find_similar_vulnerabilities(vulnerability)

        # Generate exploitation vectors
        exploitation_vectors = self._generate_exploitation_vectors(vuln_type, vulnerability)

        # Assess affected systems
        affected_systems = self._assess_affected_systems(vulnerability)

        # Check compliance violations
        compliance_violations = self._check_compliance_violations(vulnerability)

        # Calculate business impact
        business_impact = self._calculate_business_impact(score, vulnerability)

        return ClassifiedVulnerability(
            original_vulnerability=vulnerability,
            classification=score,
            enhanced_metadata=enhanced_metadata,
            similar_vulnerabilities=similar_vulns,
            exploitation_vectors=exploitation_vectors,
            affected_systems=affected_systems,
            compliance_violations=compliance_violations,
            business_impact=business_impact
        )

    def _parse_severity(self, severity_str: str) -> VulnerabilitySeverity:
        """Parse severity string to enum"""
        severity_map = {
            'critical': VulnerabilitySeverity.CRITICAL,
            'high': VulnerabilitySeverity.HIGH,
            'medium': VulnerabilitySeverity.MEDIUM,
            'low': VulnerabilitySeverity.LOW,
            'info': VulnerabilitySeverity.INFO
        }
        return severity_map.get(severity_str.lower(), VulnerabilitySeverity.MEDIUM)

    def _classify_vulnerability_type(self, title: str, description: str, vuln_type_str: str) -> VulnerabilityType:
        """Classify vulnerability type using pattern matching and keywords"""
        text_to_analyze = f"{title} {description} {vuln_type_str}".lower()

        # Try pattern matching first
        for vuln_type, patterns in self.vulnerability_patterns.items():
            for pattern in patterns:
                if re.search(pattern, text_to_analyze, re.IGNORECASE):
                    try:
                        return VulnerabilityType(vuln_type.upper())
                    except ValueError:
                        continue

        # Fallback to keyword mapping
        keyword_map = {
            'captcha': VulnerabilityType.CAPTCHA_BYPASS,
            'bulk': VulnerabilityType.BULK_CREATION,
            'validation': VulnerabilityType.WEAK_VALIDATION,
            'verification': VulnerabilityType.MISSING_VERIFICATION,
            'api': VulnerabilityType.API_EXPOSURE,
            'password': VulnerabilityType.WEAK_PASSWORD_POLICY,
            'rate': VulnerabilityType.RATE_LIMITING_BYPASS,
            'session': VulnerabilityType.SESSION_MANAGEMENT,
            'ssl': VulnerabilityType.INSECURE_COMMUNICATION,
            'information': VulnerabilityType.INFORMATION_DISCLOSURE,
            'xss': VulnerabilityType.CROSS_SITE_SCRIPTING,
            'sql': VulnerabilityType.SQL_INJECTION,
            'rce': VulnerabilityType.REMOTE_CODE_EXECUTION,
            'privilege': VulnerabilityType.PRIVILEGE_ESCALATION,
            'dos': VulnerabilityType.DENIAL_OF_SERVICE,
            'logic': VulnerabilityType.BUSINESS_LOGIC_Flaw
        }

        for keyword, vuln_type in keyword_map.items():
            if keyword in text_to_analyze:
                return vuln_type

        # Default fallback
        return VulnerabilityType.BUSINESS_LOGIC_Flaw

    def _calculate_vulnerability_score(self, severity: VulnerabilitySeverity,
                                    vuln_type: VulnerabilityType, exploitability: str,
                                    profit_potential: str, title: str, description: str,
                                    vulnerability: Dict) -> VulnerabilityScore:
        """Calculate comprehensive vulnerability score"""

        # Base severity score
        severity_score = self.severity_weights[severity]

        # Adjust for vulnerability type
        type_multipliers = self.vulnerability_type_weights.get(vuln_type, {'severity': 1.0, 'exploitability': 1.0, 'profit': 1.0})
        severity_score *= type_multipliers['severity']

        # Exploitability score
        exploitability_score = self.exploitability_factors.get(exploitability.lower(), 5.0)
        exploitability_score *= type_multipliers['exploitability']

        # Impact score (based on casino-specific factors)
        impact_score = self._calculate_impact_score(title, description, vulnerability)

        # Detection confidence (based on how well we can identify the issue)
        detection_confidence = self._calculate_detection_confidence(vulnerability)

        # Profit potential score
        profit_potential_score = self._parse_profit_potential(profit_potential)
        profit_potential_score *= type_multipliers['profit']

        # Overall score calculation (weighted average)
        overall_score = (
            severity_score * 0.25 +
            exploitability_score * 0.25 +
            impact_score * 0.25 +
            profit_potential_score * 0.15 +
            detection_confidence * 0.10
        )

        # Cap at 10.0
        overall_score = min(overall_score, 10.0)

        # Calculate priority rank (1-100)
        priority_rank = int(overall_score * 10)

        # Generate recommendations
        recommended_action = self._generate_recommended_action(severity, vuln_type, exploitability_score)
        time_to_exploit = self._estimate_time_to_exploit(exploitability_score, vuln_type)
        risk_assessment = self._assess_risk(overall_score, impact_score)
        mitigation_complexity = self._assess_mitigation_complexity(vuln_type, vulnerability)

        return VulnerabilityScore(
            overall_score=round(overall_score, 2),
            severity_score=round(severity_score, 2),
            exploitability_score=round(exploitability_score, 2),
            impact_score=round(impact_score, 2),
            detection_confidence=round(detection_confidence, 2),
            priority_rank=priority_rank,
            recommended_action=recommended_action,
            time_to_exploit=time_to_exploit,
            profit_potential_score=round(profit_potential_score, 2),
            risk_assessment=risk_assessment,
            mitigation_complexity=mitigation_complexity
        )

    def _calculate_impact_score(self, title: str, description: str, vulnerability: Dict) -> float:
        """Calculate impact score based on casino-specific factors"""
        impact_score = 5.0  # Base score

        text_to_analyze = f"{title} {description}".lower()

        # Check for casino-specific impact areas
        for area, multiplier in self.casino_impact_multipliers.items():
            if area.replace('_', ' ') in text_to_analyze:
                impact_score *= multiplier
                break

        # Adjust based on technical details
        technical_details = vulnerability.get('technical_details', {})
        if isinstance(technical_details, dict):
            if technical_details.get('forms_analyzed', 0) > 5:
                impact_score *= 1.2  # Multiple forms affected
            if technical_details.get('validation_bypass_methods'):
                impact_score *= 1.3  # Multiple bypass methods

        # Cap at 10.0
        return min(impact_score, 10.0)

    def _calculate_detection_confidence(self, vulnerability: Dict) -> float:
        """Calculate how confident we are in the vulnerability detection"""
        confidence = 7.0  # Base confidence for our scanner

        # Increase confidence based on evidence
        if vulnerability.get('proof_of_concept'):
            confidence += 1.0
        if vulnerability.get('technical_details'):
            confidence += 1.0
        if vulnerability.get('screenshots'):
            confidence += 0.5

        # Decrease confidence for certain conditions
        if 'error' in vulnerability.get('description', '').lower():
            confidence -= 2.0
        if vulnerability.get('severity') == 'info':
            confidence -= 1.0

        return max(1.0, min(confidence, 10.0))

    def _parse_profit_potential(self, profit_potential: str) -> float:
        """Parse profit potential string to numeric score"""
        profit_map = {
            'very_high': 9.0,
            'high': 7.0,
            'medium': 5.0,
            'low': 3.0,
            'n/a': 1.0
        }

        if isinstance(profit_potential, (int, float)):
            return float(profit_potential)

        return profit_map.get(profit_potential.lower(), 5.0)

    def _generate_recommended_action(self, severity: VulnerabilitySeverity,
                                   vuln_type: VulnerabilityType, exploitability_score: float) -> str:
        """Generate recommended action based on vulnerability characteristics"""

        if severity == VulnerabilitySeverity.CRITICAL and exploitability_score > 7.0:
            return "Immediate exploitation recommended - high impact, easy to exploit"

        elif severity == VulnerabilitySeverity.CRITICAL:
            return "Priority exploitation - develop exploit despite difficulty"

        elif severity == VulnerabilitySeverity.HIGH and exploitability_score > 6.0:
            return "High priority exploitation - good risk/reward ratio"

        elif vuln_type == VulnerabilityType.CAPTCHA_BYPASS:
            return "Automated account creation possible - scale exploitation"

        elif vuln_type == VulnerabilityType.BULK_CREATION:
            return "Multiple account abuse opportunity - implement farming strategy"

        elif vuln_type in [VulnerabilityType.SQL_INJECTION, VulnerabilityType.REMOTE_CODE_EXECUTION]:
            return "Critical infrastructure vulnerability - maximum priority"

        else:
            return "Monitor and assess for exploitation potential"

    def _estimate_time_to_exploit(self, exploitability_score: float, vuln_type: VulnerabilityType) -> str:
        """Estimate time required to develop working exploit"""

        if exploitability_score >= 8.0:
            return "< 1 hour"
        elif exploitability_score >= 6.0:
            return "1-4 hours"
        elif exploitability_score >= 4.0:
            return "4-24 hours"
        elif exploitability_score >= 2.0:
            return "1-7 days"
        else:
            return "1-4 weeks"

    def _assess_risk(self, overall_score: float, impact_score: float) -> str:
        """Assess overall risk level"""

        if overall_score >= 8.0 and impact_score >= 8.0:
            return "EXTREME - Immediate action required"
        elif overall_score >= 7.0 and impact_score >= 6.0:
            return "HIGH - Priority exploitation target"
        elif overall_score >= 5.0 and impact_score >= 5.0:
            return "MEDIUM - Good exploitation candidate"
        elif overall_score >= 3.0:
            return "LOW - Monitor for changes"
        else:
            return "VERY LOW - Not worth immediate attention"

    def _assess_mitigation_complexity(self, vuln_type: VulnerabilityType, vulnerability: Dict) -> str:
        """Assess how complex it would be for the casino to fix this vulnerability"""

        # Complex mitigations
        complex_types = [
            VulnerabilityType.REMOTE_CODE_EXECUTION,
            VulnerabilityType.PRIVILEGE_ESCALATION,
            VulnerabilityType.SQL_INJECTION
        ]

        if vuln_type in complex_types:
            return "very_hard"

        # Medium complexity
        medium_types = [
            VulnerabilityType.SESSION_MANAGEMENT,
            VulnerabilityType.API_EXPOSURE,
            VulnerabilityType.BUSINESS_LOGIC_Flaw
        ]

        if vuln_type in medium_types:
            return "hard"

        # Easy fixes
        easy_types = [
            VulnerabilityType.CAPTCHA_BYPASS,
            VulnerabilityType.WEAK_VALIDATION,
            VulnerabilityType.MISSING_VERIFICATION
        ]

        if vuln_type in easy_types:
            return "easy"

        return "medium"

    def _generate_enhanced_metadata(self, vulnerability: Dict, score: VulnerabilityScore) -> Dict:
        """Generate enhanced metadata for the vulnerability"""
        return {
            'classification_confidence': score.detection_confidence / 10.0,
            'automated_ranking': score.priority_rank,
            'estimated_value': self._estimate_monetary_value(score),
            'exploit_maturity': self._assess_exploit_maturity(vulnerability),
            'affected_user_base': self._estimate_affected_users(vulnerability),
            'regulatory_risk': self._assess_regulatory_risk(vulnerability),
            'brand_impact': self._assess_brand_impact(vulnerability)
        }

    def _estimate_monetary_value(self, score: VulnerabilityScore) -> str:
        """Estimate monetary value of the vulnerability"""
        base_value = score.overall_score * score.profit_potential_score * 100

        if score.overall_score >= 8.0:
            return f"${base_value * 2:,.0f}+"
        elif score.overall_score >= 6.0:
            return f"${base_value:,.0f}+"
        else:
            return f"${base_value / 2:,.0f}"

    def _assess_exploit_maturity(self, vulnerability: Dict) -> str:
        """Assess how mature/developed the exploit is"""
        if vulnerability.get('proof_of_concept'):
            return "Proof of concept available"
        elif vulnerability.get('exploitability') == 'easy':
            return "Exploit easily developable"
        elif vulnerability.get('technical_details'):
            return "Technical details available"
        else:
            return "Requires further research"

    def _estimate_affected_users(self, vulnerability: Dict) -> str:
        """Estimate number of affected users"""
        # This is a rough estimate based on vulnerability type
        vuln_type = vulnerability.get('vulnerability_type', '')

        if 'bulk' in vuln_type or 'captcha' in vuln_type:
            return "All prospective users (unlimited)"
        elif 'api' in vuln_type:
            return "All registered users"
        else:
            return "Unknown - requires investigation"

    def _assess_regulatory_risk(self, vulnerability: Dict) -> str:
        """Assess regulatory compliance risk"""
        high_risk_types = ['bulk_creation', 'missing_verification', 'weak_validation']

        if any(risk_type in vulnerability.get('vulnerability_type', '') for risk_type in high_risk_types):
            return "HIGH - May violate KYC/AML regulations"
        else:
            return "MEDIUM - General security compliance"

    def _assess_brand_impact(self, vulnerability: Dict) -> str:
        """Assess impact on casino brand/reputation"""
        if 'critical' in vulnerability.get('severity', ''):
            return "HIGH - Could lead to brand damage and loss of trust"
        elif 'high' in vulnerability.get('severity', ''):
            return "MEDIUM - Potential reputation damage"
        else:
            return "LOW - Minimal brand impact"

    def _find_similar_vulnerabilities(self, vulnerability: Dict) -> List[Dict]:
        """Find similar vulnerabilities (simplified implementation)"""
        # In a real implementation, this would search a database of known vulnerabilities
        similar = []

        vuln_type = vulnerability.get('vulnerability_type', '')
        severity = vulnerability.get('severity', '')

        # Simple similarity based on type and severity
        if vuln_type == 'captcha_bypass':
            similar.append({
                'title': 'Similar CAPTCHA bypass in CasinoXYZ',
                'severity': severity,
                'outcome': 'Successfully exploited'
            })

        return similar[:3]  # Limit to 3 similar cases

    def _generate_exploitation_vectors(self, vuln_type: VulnerabilityType, vulnerability: Dict) -> List[str]:
        """Generate potential exploitation vectors"""
        vectors = []

        if vuln_type == VulnerabilityType.CAPTCHA_BYPASS:
            vectors.extend([
                "Automated account creation scripts",
                "Botnet-based registration farming",
                "API direct submission bypass"
            ])

        elif vuln_type == VulnerabilityType.BULK_CREATION:
            vectors.extend([
                "Mass account creation for bonus abuse",
                "Referral program exploitation",
                "Affiliate system manipulation"
            ])

        elif vuln_type == VulnerabilityType.WEAK_VALIDATION:
            vectors.extend([
                "Invalid email format acceptance",
                "SQL injection through malformed input",
                "XSS through unsanitized input"
            ])

        elif vuln_type == VulnerabilityType.API_EXPOSURE:
            vectors.extend([
                "Direct API manipulation",
                "Parameter tampering",
                "Authentication bypass"
            ])

        # Add technical details-based vectors
        technical_details = vulnerability.get('technical_details', {})
        if isinstance(technical_details, dict):
            if technical_details.get('validation_bypass_methods'):
                vectors.append("Multiple validation bypass techniques available")

        return vectors[:5]  # Limit to 5 vectors

    def _assess_affected_systems(self, vulnerability: Dict) -> List[str]:
        """Assess which systems are affected by the vulnerability"""
        systems = ["User Registration System"]

        vuln_type = vulnerability.get('vulnerability_type', '')

        if 'api' in vuln_type:
            systems.append("API Infrastructure")
        if 'payment' in vulnerability.get('description', '').lower():
            systems.append("Payment Processing")
        if 'bonus' in vulnerability.get('description', '').lower():
            systems.append("Bonus & Promotion System")
        if 'game' in vulnerability.get('description', '').lower():
            systems.append("Gaming Platform")

        return systems

    def _check_compliance_violations(self, vulnerability: Dict) -> List[str]:
        """Check for potential compliance violations"""
        violations = []

        vuln_type = vulnerability.get('vulnerability_type', '')
        description = vulnerability.get('description', '').lower()

        if 'bulk' in vuln_type or 'captcha' in vuln_type:
            violations.append("KYC/AML Compliance - Account Verification Requirements")

        if 'verification' in description:
            violations.append("Regulatory Identity Verification Standards")

        if 'data' in description and 'encrypt' in description:
            violations.append("Data Protection Regulations (GDPR, CCPA)")

        return violations

    def _calculate_business_impact(self, score: VulnerabilityScore, vulnerability: Dict) -> Dict:
        """Calculate business impact assessment"""
        return {
            'financial_loss_potential': self._estimate_financial_loss(score),
            'operational_impact': self._assess_operational_impact(score),
            'customer_trust_impact': self._assess_customer_trust_impact(score),
            'regulatory_fines': self._estimate_regulatory_fines(score),
            'time_to_remediate': self._estimate_remediation_time(score.mitigation_complexity)
        }

    def _estimate_financial_loss(self, score: VulnerabilityScore) -> str:
        """Estimate potential financial loss"""
        if score.overall_score >= 8.0:
            return "$500,000+"
        elif score.overall_score >= 6.0:
            return "$100,000 - $500,000"
        elif score.overall_score >= 4.0:
            return "$10,000 - $100,000"
        else:
            return "$1,000 - $10,000"

    def _assess_operational_impact(self, score: VulnerabilityScore) -> str:
        """Assess operational impact"""
        if score.overall_score >= 8.0:
            return "CRITICAL - System compromise possible"
        elif score.overall_score >= 6.0:
            return "HIGH - Significant operational disruption"
        elif score.overall_score >= 4.0:
            return "MEDIUM - Moderate operational impact"
        else:
            return "LOW - Minimal operational impact"

    def _assess_customer_trust_impact(self, score: VulnerabilityScore) -> str:
        """Assess impact on customer trust"""
        if score.severity_score >= 8.0:
            return "SEVERE - Complete loss of customer confidence"
        elif score.severity_score >= 6.0:
            return "HIGH - Significant trust erosion"
        elif score.severity_score >= 4.0:
            return "MEDIUM - Moderate trust impact"
        else:
            return "LOW - Minimal trust impact"

    def _estimate_regulatory_fines(self, score: VulnerabilityScore) -> str:
        """Estimate potential regulatory fines"""
        if score.overall_score >= 8.0:
            return "$1M+ (Major regulatory violations)"
        elif score.overall_score >= 6.0:
            return "$100K - $1M"
        elif score.overall_score >= 4.0:
            return "$10K - $100K"
        else:
            return "$1K - $10K"

    def _estimate_remediation_time(self, complexity: str) -> str:
        """Estimate time to remediate"""
        complexity_map = {
            'easy': '1-3 days',
            'medium': '1-2 weeks',
            'hard': '2-6 weeks',
            'very_hard': '1-6 months'
        }
        return complexity_map.get(complexity, 'Unknown')

    def generate_priority_report(self, classified_vulnerabilities: List[ClassifiedVulnerability],
                               output_format: str = 'json') -> str:
        """Generate a priority-based vulnerability report"""

        # Sort by priority rank
        sorted_vulns = sorted(classified_vulnerabilities,
                            key=lambda x: x.classification.priority_rank,
                            reverse=True)

        report = {
            'generated_at': datetime.now().isoformat(),
            'total_vulnerabilities': len(sorted_vulns),
            'priority_distribution': self._calculate_priority_distribution(sorted_vulns),
            'top_vulnerabilities': [self._format_vulnerability(v) for v in sorted_vulns[:10]],
            'exploitation_readiness': self._assess_exploitation_readiness(sorted_vulns),
            'recommended_targets': [self._format_vulnerability(v) for v in sorted_vulns
                                  if v.classification.overall_score >= 7.0][:5]
        }

        if output_format == 'json':
            return json.dumps(report, indent=2, default=str)
        else:
            return self._generate_text_report(report)

    def _calculate_priority_distribution(self, vulnerabilities: List[ClassifiedVulnerability]) -> Dict:
        """Calculate distribution of vulnerabilities by priority"""
        distribution = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0}

        for vuln in vulnerabilities:
            score = vuln.classification.overall_score
            if score >= 8.0:
                distribution['critical'] += 1
            elif score >= 6.0:
                distribution['high'] += 1
            elif score >= 4.0:
                distribution['medium'] += 1
            else:
                distribution['low'] += 1

        return distribution

    def _format_vulnerability(self, vuln: ClassifiedVulnerability) -> Dict:
        """Format vulnerability for reporting"""
        return {
            'title': vuln.original_vulnerability.get('title'),
            'severity': vuln.original_vulnerability.get('severity'),
            'type': vuln.original_vulnerability.get('vulnerability_type'),
            'url': vuln.original_vulnerability.get('url'),
            'priority_score': vuln.classification.priority_rank,
            'overall_score': vuln.classification.overall_score,
            'recommended_action': vuln.classification.recommended_action,
            'time_to_exploit': vuln.classification.time_to_exploit,
            'profit_potential': vuln.classification.profit_potential_score,
            'risk_assessment': vuln.classification.risk_assessment
        }

    def _assess_exploitation_readiness(self, vulnerabilities: List[ClassifiedVulnerability]) -> Dict:
        """Assess overall exploitation readiness"""
        ready_count = sum(1 for v in vulnerabilities if v.classification.exploitability_score >= 7.0)
        high_impact_count = sum(1 for v in vulnerabilities if v.classification.overall_score >= 8.0)

        return {
            'ready_to_exploit': ready_count,
            'high_impact_opportunities': high_impact_count,
            'average_exploitability': sum(v.classification.exploitability_score for v in vulnerabilities) / len(vulnerabilities),
            'average_profit_potential': sum(v.classification.profit_potential_score for v in vulnerabilities) / len(vulnerabilities)
        }

    def _generate_text_report(self, report_data: Dict) -> str:
        """Generate a human-readable text report"""
        lines = [
            "=" * 80,
            "CASINO VULNERABILITY PRIORITY REPORT",
            "=" * 80,
            f"Generated: {report_data['generated_at']}",
            f"Total Vulnerabilities: {report_data['total_vulnerabilities']}",
            "",
            "PRIORITY DISTRIBUTION:",
            f"  Critical (>8.0): {report_data['priority_distribution']['critical']}",
            f"  High (6.0-8.0): {report_data['priority_distribution']['high']}",
            f"  Medium (4.0-6.0): {report_data['priority_distribution']['medium']}",
            f"  Low (<4.0): {report_data['priority_distribution']['low']}",
            "",
            "EXPLOITATION READINESS:",
            f"  Ready to Exploit: {report_data['exploitation_readiness']['ready_to_exploit']}",
            f"  High Impact Opportunities: {report_data['exploitation_readiness']['high_impact_opportunities']}",
            f"  Average Exploitability: {report_data['exploitation_readiness']['average_exploitability']:.1f}/10",
            f"  Average Profit Potential: {report_data['exploitation_readiness']['average_profit_potential']:.1f}/10",
            "",
            "TOP RECOMMENDED TARGETS:",
        ]

        for i, vuln in enumerate(report_data['recommended_targets'][:5], 1):
            lines.extend([
                f"{i}. {vuln['title']}",
                f"   Priority: {vuln['priority_score']}/100 | Score: {vuln['overall_score']}/10",
                f"   Action: {vuln['recommended_action']}",
                f"   Time to Exploit: {vuln['time_to_exploit']}",
                ""
            ])

        lines.extend(["=" * 80])
        return "\n".join(lines)


# Standalone classification function
def classify_vulnerabilities(vulnerabilities: List[Dict]) -> List[ClassifiedVulnerability]:
    """Standalone function to classify vulnerabilities"""
    classifier = VulnerabilityClassifier()
    return classifier.classify_vulnerabilities(vulnerabilities)


if __name__ == "__main__":
    # Example usage
    sample_vulnerabilities = [
        {
            'title': 'No CAPTCHA Protection on Signup',
            'description': 'Signup form lacks CAPTCHA protection allowing automated account creation',
            'severity': 'critical',
            'vulnerability_type': 'captcha_bypass',
            'exploitability': 'easy',
            'profit_potential': 'very_high'
        },
        {
            'title': 'Weak Email Validation',
            'description': 'Email field accepts invalid formats and allows duplicate registrations',
            'severity': 'high',
            'vulnerability_type': 'weak_validation',
            'exploitability': 'easy',
            'profit_potential': 'high'
        }
    ]

    classifier = VulnerabilityClassifier()
    classified = classifier.classify_vulnerabilities(sample_vulnerabilities)

    # Generate report
    report = classifier.generate_priority_report(classified)
    print(report)
